from typing import List, Tuple, TypeVar, Generic

def restaurantFinder(d: int, site_list: List[int]) -> Tuple[int, List[int]]:
    """
    Function description:
    The restaurantFinder function finds the best combination of restaurants that are distanced with one another, with
    the constraint that is d, the distance for which restaurants chosen must not be in vicinity of each other. Each
    restaurant is represented by its revenue and the functions aims to return the maximum amount of revenue possible
    along with a list of restaurants' indexes.

    Approach description:
    The function uses dynamic programming to compute the maximum revenue that can be generated up to each site. Two
    lists: revenue and sites, are intialized. Both of length equal to the number of sites. The revenue list will store
    the maximum revenue that can be obtained up to each site, while the sites list will store the indices of the chosen
    sites. The function then iterates through the list of site revenues. If the current index i is less than d, which
    represents the sites within a distance of d, there are two options, to add the current site in the chosen sites
    if its revenue is greater than the revenue obtained so far. Otherwise, ignore the current site and continue with
    the previous revenue. If i is greater than or equal to d, there are also two options. Add the current site and
    calculate the total revenue by adding the revenue of the current site and the revenue obtained from sites that are
    at least d units away. If i-d-1 is less than 0, it means the list has reached its beginning and it is replaced by 0
    instead. Or, it ignores the current site and continue with the previous maximum revenue. The option is the one that
    results in higher revenue and the function updates both revenue[i] and sites[i] accordingly. After processing all
    sites, the maximum total revenue is found in revenue[-1], and the indices of the chosen sites are found in sites[-1].

    :Input:
    d (int): The distance for which restaurants chosen must not be in vicinity of each other.
    site_list (List[int]): A list of integers representing the revenue generated by each site.
    :Output, return or postcondition:
    Tuple[int, List[int]]: A tuple containing the maximum total revenue achievable and
    a list of indices representing the chosen sites.
    :Time complexity:
    O(N) where N is the number of sites. The function iterates through the list of site revenues once, performing
    constant time operations at each site.
    :Aux space complexity:
    O(N) where N is the number of sites. The function uses two lists: revenue and sites, to store information about each
    site. These lists have the same length as the number of sites.
    """
    # Initialize two lists to keep track of revenue and selected sites
    revenue = [0] * len(site_list)  # To store the maximum revenue at each step
    sites = [[] for _ in range(len(site_list))]  # To store the selected sites
    # Iterate through the site_list
    for i in range(len(site_list)):
        # If site is within d
        if i < d:
            if site_list[i] > revenue[i - 1]:
                # If the current site's revenue is greater, update the revenue
                revenue[i] = site_list[i]
                # Store the index of the current site as the selected site
                sites[i] = [i]
            else:
                # Keep the previous revenue and selected sites otherwise
                revenue[i] = revenue[i - 1]
                sites[i] = sites[i - 1][:]
        # After the first d sites
        else:
            add_site = (revenue[i - 1 - d] if i - 1 - d >= 0 else 0) + site_list[i]
            ignore_site = revenue[i - 1 if i - 1 >= 0 else 0]
            if add_site > ignore_site:
                # If adding the current site results in higher revenue
                revenue[i] = add_site
                # Store the selected sites from d steps ago and add the current site
                sites[i] = sites[i - 1 - d][:] if i - 1 - d >= 0 else []
                sites[i].append(i)
            else:
                # If ignoring the current site results in higher revenue
                revenue[i] = ignore_site
                # Keep the selected sites from the previous step
                sites[i] = sites[i - 1][:]
    # Return the maximum revenue and the selected sites
    return revenue[-1], [site + 1 for site in sites[-1]]

"""
The class ArrayR and MinHeap are referenced from Monash Unit FIT1008 in Edsteem, specifically Week 11's Applied Theory: 
The Top K exercise.
"""

T = TypeVar('T')

class ArrayR(Generic[T]):
    def __init__(self, length: int) -> None:
        """ Creates an array of references to objects of the given length
        :complexity: O(length) for best/worst case to initialise to None
        :pre: length > 0
        """
        if length <= 0:
            raise ValueError("Array length should be larger than 0.")
        self.array =  [None for _ in range(length)]

    def __len__(self) -> int:
        """ Returns the length of the array
        :complexity: O(1)
        """
        return len(self.array)

    def __getitem__(self, index: int) -> T:
        """ Returns the object in position index.
        :complexity: O(1)
        :pre: index in between 0 and length - self.array[] checks it
        """
        return self.array[index]

    def __setitem__(self, index: int, value: T) -> None:
        """ Sets the object in position index to value
        :complexity: O(1)
        :pre: index in between 0 and length - self.array[] checks it
        """
        self.array[index] = value

class MinHeap(Generic[T]):
    MIN_CAPACITY = 1

    def __init__(self, max_size: int) -> None:
        self.length = 0
        self.the_array = ArrayR(max(self.MIN_CAPACITY, max_size) + 1)

    def __len__(self) -> int:
        return self.length

    def is_full(self) -> bool:
        return self.length + 1 == len(self.the_array)

    def rise(self, k: int) -> None:
        """
        Rise element at index k to its correct position
        :pre: 1 <= k <= self.length
        """
        item = self.the_array[k]
        while k > 1 and item[0] < self.the_array[k // 2][0]:  # Compare using the first element of the tuple as the key
            self.the_array[k] = self.the_array[k // 2]
            k = k // 2
        self.the_array[k] = item

    def add(self, element: T) -> None:
        """
        Swaps elements while rising
        """
        if self.is_full():
            raise IndexError
        self.length += 1
        self.the_array[self.length] = element
        self.rise(self.length)

    def smallest_child(self, k: int) -> int:
        """
        Returns the index of k's child with the smallest key.
        :pre: 1 <= k <= self.length // 2
        """
        if 2 * k == self.length or \
                self.the_array[2 * k][0] < self.the_array[2 * k + 1][0]:  # Compare using the first element of the tuple as the key
            return 2 * k
        else:
            return 2 * k + 1

    def sink(self, k: int) -> None:
        """ Make the element at index k sink to the correct position.
            :pre: 1 <= k <= self.length
        """
        item = self.the_array[k]
        while 2 * k <= self.length:
            min_child = self.smallest_child(k)  # Find the child with the smallest key
            if self.the_array[min_child][0] >= item[0]:  # Compare using the first element of the tuple as the key
                break
            self.the_array[k] = self.the_array[min_child]
            k = min_child
        self.the_array[k] = item

    def serve(self) -> T:
        """ Remove (and return) the minimum element from the heap. """
        if self.length == 0:
            raise IndexError
        min_elt = self.the_array[1]
        self.length -= 1
        if self.length > 0:
            self.the_array[1] = self.the_array[self.length+1]
            self.sink(1)
        return min_elt

    def update(self, key: int, new_value: T) -> None:
        """ Update the value of an item in the heap based on its key. """
        index = None # Find the index of the item with the matching key
        for i in range(1, self.length + 1):
            if self.the_array[i][0] == key:  # Assuming the key is stored in the first element of the tuple
                index = i
                break
        if index is not None:
            self.the_array[index] = (key, new_value) # Update the value of the item
            # Check if the updated item needs to be moved up (rise) or down (sink) in the heap
            parent_index = index // 2
            if parent_index > 0 and self.the_array[index][0] < self.the_array[parent_index][0]:
                self.rise(index)
            else:
                self.sink(index)

class FloorGraph:
    def __init__(self, paths: List[Tuple[int, int, int]], keys: List[Tuple[int, int]]):
        """
        Function description:
        Class constructor for FloorGraph that initializes a FloorGraph object with given paths and keys. Creates
        vertices and edges based on the input and stores reverse_path and keys to for another function to use it and
        create a reverse graph.

        :Input:
        paths (List[Tuple[int, int, int]]): A list of tuples representing paths with (u, v, x), where u and v are vertex
         IDs and x is the time taken to go from u to v.
        keys (List[Tuple[int, int]]): A list of tuples representing keys with (k, y), where k is the vertex ID and y is
        the key value.
        :Output, return or postcondition:
        None
        :Time complexity:
        O(E + V) where E is the number of edges and V is the number of vertices. The function iterates through both
        paths and keys lists once.
        :Aux space complexity:
        O(E + V) where E is the number of edges and V is the number of vertices. The function creates two lists:
        self.vertices and self.reverse_path with the length of paths which is the same as number of edges. It also loops
        through the number of keys which can be up to the number of vertices.
        """
        # Initialize lists to store vertices, reversed paths and keys
        # self.vertices has len(paths) + 1 size because there can be only 1 edge with 2 vertices
        self.vertices = [None] * (len(paths) + 1)
        self.reverse_path = [None] * len(paths)
        self.keys = keys
        # Iterate through the paths and process each one
        for i in range(len(paths)):
            u, v, x = paths[i]
            # Create a reverse path (v, u, x) and store it
            self.reverse_path[i] = (v, u, x)
            # Check if vertex u doesn't exist, create it
            if self.vertices[u] is None:
                self.vertices[u] = Vertex(u)
            # Check if vertex v doesn't exist, create it
            if self.vertices[v] is None:
                self.vertices[v] = Vertex(v)
            # Add an edge (u, v, x) to vertex u's list of edges
            self.vertices[u].edges.append(Edge(u, v, x))
        # Filter out None values from the vertices list
        self.vertices = [v for v in self.vertices if v is not None]
        # Iterate through the keys and assign them to respective vertices
        for j in range(len(keys)):
            k, y = keys[j]
            self.vertices[k].key = y

    def reset(self):
        """
        Function description:
        Resets the state of vertices in the graph. Sets the discovered, visited, time, and previous attributes of each
        vertex to their initial values to prevent the residual data from interfering with later actions of the graph.

        :Input:
        None
        :Output, return or postcondition:
        None
        :Time complexity:
        O(V) where V is the number of vertices. The function iterates through all vertices once.
        :Aux space complexity:
        None
        """
        for v in self.vertices:
            v.discovered = False
            v.visited = False
            v.time = float('inf')
            v.previous = None

    def climb(self, start: int, exits: List[int]) -> Tuple[int, List[int]]:
        """
        Function description:
        Finds the optimal path for climbing through the graph from the start to exits. Computes the optimal path to
        climb from the start vertex to one of the exits vertices in the graph and in the process going to one of the
        vertices that contains a key to acquire it as key is needed to go to the next floor. Resets self.vertices
        multiple time in the process to have it in its original state that respond to changes.

        Approach description:
        The climb function computes the optimal path for traversing a multi-level graph, considering key acquisition and
        reaching an exit. It employs Dijkstra's algorithm to find the shortest paths from the starting vertex to all
        other vertices and creates a reversed graph with a proxy location that is within 0 time of each exit vertex.
        This serves to find the vertex with key that has the minimum time required, from start and exit and for the
        acquisition of the key. The function then assembles the final path by concatenating routes from the start to the
        vertex that contains the key and from there to the selected exit. The result is a tuple containing the total
        time and the concatenated path. If no valid route exists, it returns None.

        :Input:
        start (int): The ID of the starting vertex.
        exits (List[int]): A list of IDs of exit vertices.
        :Output, return or postcondition:
        Tuple[int, List[int]] or None: A tuple containing the total time and the path, or None if there's no valid route.
        :Time complexity:
        O(ElogV) where V is the number of vertices and E is the number of edges. The function performs the dijkstra
        method multiple times with a complexity of O(ElogV). It also performs the reverse_graph method for a complexity
        of O(V). Other operations like looping through self.vertices, calling reset method to reset vertices and popping
        path_to_exit at 0 all results in a complexity of O(V). However, O(ElogV) is greater than O(V) and that is why it
        all boils down to O(ElogV).
        :Aux space complexity:
        O(V+E) where V represents the number of vertices and E represents the number of edges for calling the
        reverse_graph method and creating the reversed graph with self.reverse_path and self.keys.
        """
        # Time to compare and return
        time = float('inf')
        # Run Djikstra's algorithm to find the shortest paths from the start vertex to all vertices
        start_dijkstra = self.dijkstra(start)
        # Create a reversed graph that calculates the shortest paths from the exit to all vertices
        reverse_graph = self.reverse_graph(exits)
        # Run Djikstra's algorithm to find the shortest path from the proxy vertex to all vertices in the reversed graph
        end_dijkstra = reverse_graph.dijkstra(reverse_graph.vertices[len(reverse_graph.vertices) - 1].id)
        # Remove proxy vertex
        reverse_graph.vertices.pop()
        # Iterate through all vertices
        for v in self.vertices:
            # Check if the vertex contains a key
            if v.key is not None:
                if start_dijkstra[v.id] is not None and end_dijkstra[v.id] is not None:
                    # Calculate the total time from start and exit to acquire the key and reach the exit
                    current_time = start_dijkstra[v.id] + end_dijkstra[v.id] + v.key
                else:
                    # Return None where there is no valid route to an exit
                    return None
                # Set the key vertex as id of v if its time is shorter
                if current_time < time:
                    v_for_key = v.id
                # Set time as the minimum from current time and previous time
                time = min(current_time, time)
        # Find the shortest path from the start to the vertex that contains a key
        path_to_key = self.find_shortest_path(start, v_for_key)
        # Reset before performing dijkstra function again
        self.reset()
        # Run Djikstra's algorithm to find the shortest paths from the key vertex to all exit vertices
        exit_dijkstra = self.dijkstra(self.vertices[v_for_key].id)
        # Get the exit vertex as the minimum of a Dijkstra list that returns a list of distance, if it is not None
        v_for_exit = exit_dijkstra.index(min(exit_dijkstra[e] for e in exits if exit_dijkstra[e] is not None))
        # Reset before performing dijkstra function again
        self.reset()
        # Find the exit vertex with the shortest time
        path_to_exit = self.find_shortest_path(v_for_key, v_for_exit)
        # Remove the first vertex that will be duplicate
        path_to_exit.pop(0)
        # Reset after performing all actions to leave it a clean slate
        self.reset()
        # Return the total time and the concatenated path
        return time, path_to_key + path_to_exit

    def reverse_graph(self, exits: List[int]):
        """
        Function description:
        Creates a reversed graph with a proxy vertex that connects to all exits with a time of 0.

        Approach description:
        The function creates a reversed graph representation and introduces a proxy vertex connected to all exit
        vertices with zero-time edges. The process begins by initializing a new FloorGraph object to represent the
        reversed graph. Then, a proxy vertex is added to the reversed graph, acting as a central hub. Subsequently, the
        function iterates through the list of exit vertex IDs and establishes edges between the proxy vertex and each
        exit vertex with zero-time weights. The resulting graph effectively reverses the direction of connections.

        :Input:
        exits (List[int]): A list of IDs of exit vertices.
        :Output, return or postcondition:
        FloorGraph: A new FloorGraph object representing the reversed graph.
        :Time complexity:
        O(V) where V represents the number of vertices as the function loops through the exits and the number of exits
        can be as many as the number of vertices in the graph.
        :Aux space complexity:
        O(V+E) where V represents the number of vertices and E represents the number of edges for calling the
        FloorGraph constructor method and creating the reversed graph with self.reverse_path and self.keys.
        """
        # Create a new FloorGraph to represent the reversed graph
        reverse_graph = FloorGraph(self.reverse_path, self.keys)
        # Create a proxy vertex to connect to all exits with a time of 0
        proxy = len(reverse_graph.vertices)
        reverse_graph.vertices.append(None)
        reverse_graph.vertices[proxy] = Vertex(proxy)
        # Create edges from the proxy vertex to all exit vertices with a time of 0
        for exit in exits:
            reverse_graph.vertices[proxy].edges.append(Edge(reverse_graph.vertices[proxy].id, exit, 0))
        # Return the new FloorGraph representing the reversed graph
        return reverse_graph

    def find_shortest_path(self, source_int:int, destination_int: int):
        """
        Function description:
        Finds the shortest path between two vertices. Computes the shortest path from a source vertex to a destination
        vertex using Dijkstra's algorithm.

        Approach description:
        The function uses dijkstra's algorithm to compute the shortest distances and then reconstructs the shortest path
        by backtracking from the destination to the source.

        :Input:
        source_int (int): The ID of the source vertex.
        destination_int (int): The ID of the destination vertex.
        :Output, return or postcondition:
        List[int]: A list of vertex IDs representing the shortest path.
        :Time complexity:
        O(ElogV) where V represents the number of vertices and E represents the number of edges in the graph when the
        function calls the dijkstra function to find out the shortest path leading to all vertices. The function also
        iterates through the previous attribute of vertices and reverses the list of vertices: path_list, both for a
        complexity of O(V) but O(ElogV) is larger.
        :Aux space complexity:
        O(V) where V represents the number of vertices, for storing and adding the shortest path in the path_list, which
        can be up to the number of vertices in the graph.
        """
        # Run Dijkstra's algorithm to compute shortest paths from the source vertex
        self.dijkstra(source_int)
        # Initialize a list to store the shortest path from destination to source
        path_list = [self.vertices[destination_int].id]
        # Trace back from the destination vertex to the source vertex to construct the path
        prev = self.vertices[destination_int].previous
        while prev is not None:
            path_list.append(prev.id)
            prev = prev.previous
        # Reverse the path list to get the path from source to destination
        path_list.reverse()
        # Return the list of vertex IDs representing the shortest path
        return path_list

    def dijkstra(self, source_int: int):
        """
        Function description:
        This function applies Dijkstra's algorithm to find the shortest path from a source vertex to all other vertices.

        Approach description:
        The function works by maintaining a priority queue specifically a MinHeap of (vertex.time, vertex.id) to
        explore, starting from the source vertex and gradually moving to neighboring vertices with the minimum
        accumulated time. It iterates until all vertices have been visited, and it updates the shortest time and
        previous vertex for each vertex encountered.

        :Input:
        source_int (int): The ID of the source vertex.
        :Output, return or postcondition:
        None
        :Time complexity:
        O(ElogV) where V represents the number of vertices and E represents the number of edges. The function uses a
        priority queue specifically a MinHeap to sort the vertices with its time. It iterates through the MinHeap for
        the number of vertices time because the discovered MinHeap can have at most all vertices in the graph. This has
        a complexity of O(V). The complexity is O(log V) for MinHeap's rise and sink operations when the MinHeap's input
        size is the number of vertices. These operations are used when the MinHeap adds, serves and updates elements.
        While looping through the discovered MinHeap, the function also loops through each edges of a vertex in the
        MinHeap. The number of edges each vertex can have is at most the number of vertices - 1 so this has a complexity
        of O(V). The overall time complexity is O(V^2logV), which will be O(ElogV) for a dense graph as V^2 is
        approximately E.
        :Aux space complexity:
        O(V) where V represents the number of vertices for creating the list time with the number of vertices and the
        MinHeap discovered.
        """
        # Get the source vertex and initialize its time as 0
        source = self.vertices[source_int]
        source.time = 0
        # Initialize a list to store time values, initially set to None
        times = [None] * len(self.vertices)
        # Set the source time to 0
        times[source_int] = 0
        # Create a MinHeap and add the source vertex
        discovered = MinHeap(len(self.vertices))
        discovered.add((source.time, source.id))
        # Loops through MinHeap
        while len(discovered):
            # Extract the vertex with the minimum time from the priority queue
            u = self.vertices[discovered.serve()[1]]
            u.discovered = True
            u.visited = True
            times[u.id] = u.time
            # Explore neighboring vertices
            for edge in u.edges:
                v = self.vertices[edge.v]
                if not v.discovered:
                    # If the neighbor is not discovered, update its time and previous vertex
                    v.discovered = True
                    v.time = u.time + edge.x
                    v.previous = u
                    discovered.add((v.time, v.id))
                else:
                    if not v.visited:
                        # If the neighbor has been discovered but not visited, check if there's a shorter path
                        if v.time > u.time + edge.x:
                            v.time = u.time + edge.x
                            v.previous = u
                            # Update the neighbor's time in the priority queue
                            discovered.update(v, v.time)
        # Return the list of shortest times from the source vertex to all other vertices
        return times

class Vertex:
    def __init__(self, id: int):
        """
        Function description:
        Class constructor for Vertex.

        :Input:
        id (int): The ID of the vertex.
        :Output, return or postcondition:
        None
        :Time complexity:
        O(1)
        :Aux space complexity:
        None
        """
        self.id = id
        self.edges = []
        self.key = None
        self.time = float('inf')
        self.discovered = False
        self.visited = False
        self.previous = None

class Edge:
    def __init__(self, u: int, v: int, x: int):
        """
        Function description:
        Class constructor for Edge.

        :Input:
        u (int): ID of the source vertex u.
        v (int): ID of the destination vertex v.
        x (int): Time taken to go from u to v.
        :Output, return or postcondition:
        None
        :Time complexity:
        O(1)
        :Aux space complexity:
        None
        """
        self.u = u
        self.v = v
        self.x = x

if __name__ == "__main__":
    print(restaurantFinder(1,[50, 10, 12, 65, 40, 95, 100, 12, 20, 30]))
    print(restaurantFinder(2,[50, 10, 12, 65, 40, 95, 100, 12, 20, 30]))
    print(restaurantFinder(3,[50, 10, 12, 65, 40, 95, 100, 12, 20, 30]))
    print(restaurantFinder(7,[50, 10, 12, 65, 40, 95, 100, 12, 20, 30]))
    print(restaurantFinder(0,[50, 10, 12, 65, 40, 95, 100, 12, 20, 30]))
    paths = [(0, 1, 4), (1, 2, 2), (2, 3, 3), (3, 4, 1), (1, 5, 2),
             (5, 6, 5), (6, 3, 2), (6, 4, 3), (1, 7, 4), (7, 8, 2),
             (8, 7, 2), (7, 3, 2), (8, 0, 11), (4, 3, 1), (4, 8, 10)]
    keys = [(5, 10), (6, 1), (7, 5), (0, 3), (8, 4)]
    myfloor = FloorGraph(paths, keys)
    print(myfloor.climb(1, [7, 2, 4]))
    print(myfloor.climb(7, [8]))
    print(myfloor.climb(1, [3, 4]))
    print(myfloor.climb(1, [0, 4]))
    print(myfloor.climb(3, [4]))